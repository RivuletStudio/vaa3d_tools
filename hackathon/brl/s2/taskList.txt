11/30 fixed the incomingTileStatus in handleNewLocations().  this fixes the MIP problem but still doesn't solve all of the retracing cases.  It seems like it's mostly a problem in dense areas.

what happens if 2 tiles are waiting for a tile's SWC file?


11/29
there is still some case where tiles arent getting added to scanData.txt. I think it's possible for the tile to be 'waited for' but have all of the tips then spoken for, resulting in
zero tips coming back to handleNewLocations, so the tileStatus isn't changed from -1 to 1.
There needs to be another check around L1875 in S2UI to update the tileStatus even if the length of the tiplist is zero.  not clear how to do this yet. tileStatus is set based on
the fileInfoList, which is based on the coordinates.  I suppose that couldbe done before the length of the landmarklist is checked?

also add signal and slot to check how many things are in the s2monitor...
then 3. below.


11/21/2016
1. work on documentation using doxygen blocks in header files
2. doublecheck endgame stuff with final stacks that could get sent around with -1 status and therefore miss the loadMIP call.
3. more endgame stuff with call to new method that does some kind of metacheck on the tiles, who's running analysis (?) and a spot
to even check on structure, etc.  this should also have the power to load new locations in future versions.





current problem:
1.I'm ending up with multiple nearly-simultaneous returns from stackAnalyzer threads to s2UI, even for basic one-tile-at-a-time scenarios.

>>>>>DO THIS NOWWWWWW  >>>>>
2.handleNewLocations will run loadMIP for tiles that have already been imaged and traced, which is very bad for my scanList queueing!!!!!



I need a way to keep track of how many times a tile has been run through the system.  the logical way is to increment tileStatus each time it goes around the loop WITH DATA.
but this might not actually increment since it's from multiple threads.  e.g. these cases tonight where there are 2x or 4x stackAnalyzer calls on something that has just been scanned.


I corrected a couple spots in the calls to SATrace stuff where multiple calls could be generated if the trace thread number was incremented while it was being evaluated;






That was likely due in part to missed numbers (rounding to integer), although I'm not totally sure. there was no obvious miss-location information


CURRENT PROBLEM:
tile location on secondary wait-for-.swc files is incorrect, resulting in incoming D.marker files that are incorrectly located?!
1. make sure the offset back and forth are consistently handled
2. make sure the tile location gets moved when the retraced file is accessed... [[[I bet it's not]]]

3.  the last scan is weird- tile 14 is correctly re-incorporated (yay) but doesn't generate new tips to be scanned.

This is because of (2).  tile 7 actually got doublechecked when it shouldn't have, right when tile 14 got finished.
so the tip locations generated by the reincorporation of 14 were put back in the tile location of 7 because
that's where they originated?

because it never modifies the tileLocation when it comes back?  or what?

first place to check is handleNewLocation





what i did:  check .swc status in s2ui then go right back to stackanalyzer.








NEW PLAN:

1. eliminate all the checking of .v3draw and .swc files as flow control within SA::startTracing.  It doesnt belong there.
2. instead, use isDuplicate input (currently bool, should be int) to control action of starTracing
3. use the flow from s2ui to Stackanalyzer and back as the loop to check for .swc status with tileStatus = -1.  The checking of the .swc file will be done in
stackanalyzer- whenever a tileStatus = -1 signal comes in, (tileStatus needs to be kept track of...) check for the .swc file, if it's not there, wait and then check again.

CRITICAL:   3. relies on there being a single sequence of events for each tile that can lead it from tileStatus = -1 to tileStatus = 1 without generating any changes to the lists, etc



whew!  so finally got the not-ready-yet locations to flow through successfully, but flow through they do and clog up the whole system
2 possibilities:
1. keep track of times
2. modify loadDuplicate to behave differently for these locations
3. make new Queue to handle exactly this kind of

ALSO
the multithreaded endgame isnt really all tied up.  problem with residual tiles that are being waited for or analysis that's still running.
NOTE: this is due to the tiles in the ether not being contained in either the scanlist or the tilelist
ALSO

what if a tile location is off by an integer due to some stupid rounding shit?



OK, solution time!
1. race condition where s2UI thinks tile 'isDuplicate' because of allROI and scanList data, but .swc doesnt actually exist yet
2. make .marker file name change when 'isDuplicate'






the fundamental problem is that for a child of a duplicate tile that is already scanned you don't know what to call the full filename (e.g. you scan tile 0, and then tile 1 to its right.  then you may be prompted to
go back into tile 0, which has already been scanned. if the .swc file exists, you check that .swc file in tile 0.  then what?  you may be prompted to check again in tile 1.

tile 1 is already scanned, but tile 0 doesn't know the full filename of the .swc file for tile 1, and it uses the filename from the last real .v3draw file which is propagated through the locationSimple struct.

the solution to this is to check for the existance of an .swc file with the same tile coordinates, ignoring the intervening filename info which is acquisition specific.
that way, when you come back around to tile 1, you can check for its existance without paying attention to the full filename of the last real .v3draw file.






DONEDONEDONE.  for future versions, this can

TileInfo readout:  append current tile info to a file in loadMIP. this should include
1. tile filename
2. tile location in pixels
3. tile size in pixels
4. tile times 0-3
5. optical zoom
6. current mode

file should be initiated at the beginning of the s2scan, and should contain

1. current time
2. git hash
3. scan save directory (to validate location)



TUESDAY:
figure out conditions of waitingforlast etc under multithreading.
how can we be sure the scan is over?  allroilocations is empty AND there are no more pending analyses

NOW:

Add time data to tileInfo.
just use time::whatever() to put current clock time into the tileInfo when:

0. target is chosen from overview [multiple targets share this starting time]
1. tile is added to queue  << S2UI::handleNewLocation
2. tile is sent to microscope
3. tile is returned from microscope
4. tile is sent to analysis
5. tile is returned from analysis :  this is made more difficult if there are recurrent returns of tiles.




progress so far 10/14
1. have s2monitor and s2scandata classes sketched out
2. s2scandata can write images of scans updated for each added tile


next

3. should just write the same filename for each scan, updating continuously


4. should add tile number in different color DONE



5. should link tile number to rows in a summary file with
a. tile number
b. actual path to .v3draw file
c. time for imaging
d. time for analysis




and other updates to UI:
single color for each s2scan, same color for tiles and text numbers DONE
can I get a rollover to spit back the tile filename?  DONE









Things are working OK now with Zhi's added code to try to avoid rescanning areas where we already have reconstructions.

biggest task today is to get a legitimate logging system working that can



1. maintain relevant information for each tile in a centralized location
2. maintain global information and current statistics
3. constantly write info to a file that can be easily interpretted by external programs

specifics:
0. Global info
pixel size, acquisition info? (no, just use .xml file)
s2 plugin application start time
?compile-time repo commit hash [added, doesn't know when hash has actually changed]

1. s2scan info
start time, tile info (see below) for each tile [there is actually sequential numbers for this now]
ongoing, updated at defined reference times like right after each stack collection.
nTiles in queue to image
nTiles in analysis
nTiles

final versions of ongoing (above)


2. Tile Info:
tile area (pixels)
tile location (pixels)





-----------



keep everything by modifying flag and distance in stackAnalyzer L335...




fudge.  I tried 1.2 below with 4 threads for tracing, but of course they're truly asynchronous and converge back into one node that's trying
to run a  FIFO list based on scan order.  if a tile comes back faster because it's more sparse or whatever, the result is garbage because
my code expects it to be the tile last picked from the list!

need to revise this scheme to instead have a growing list of tiles and when the data is sent over to stackAnalyzer, add the index of that list to
some field in the location struct.




NEXT:
1.  get more cores involved in tracing.  either 1) figure out how to spawn, connect, run and destroy a stackAnalyzer for each image or
2.) hand-code N = 3? threads for this purpose.

improve timing documentation and online metaAnalysis
1. add a simple clock for each s2scan.  this is like 2 calls to qt.time and recording the data in a new txt file
2. add a simple clock for each tile.  this will be more tricky, but relatively straightforward. up to 100s of tiles, so each s2 scan can have a summary
file that includes this stuff, I think.  relevant data: start signal time, analysis start time, analysis finish time.  the hangup here is that
everything needs to be asynchronous and previously I just relied on serial ordering to try to sort things out.  It should be done with a hash of somekind
or even just a unique identifier generated for each tile (good idea)
3. other tile info?  area, nVoxels, npixXY, some filename info...


FINALLY FIXED Monday 9AM

TO DO ON MONDAY:

void S2UI::updateROIPlot(QString ignore){
    //roiRect.moveLeft(roiXEdit->text().toFloat());
    //roiRect.setY(roiYEdit->text().toFloat());
    //qDebug()<<"y="<<roiYEdit->text().toFloat();
    roiGS->removeItem(newRect);
    float leftEdge = roiXEdit->text().toFloat() -roiXWEdit->text().toFloat()/2.0-uiS2ParameterMap[5].getCurrentValue();
    float topEdge = roiYEdit->text().toFloat() - roiYWEdit->text().toFloat()/2.0+uiS2ParameterMap[6].getCurrentValue();
    newRect =  roiGS->addRect(leftEdge,topEdge,roiXWEdit->text().toFloat(),roiYWEdit->text().toFloat());
    //newRect =  roiGS->addRect(uiS2ParameterMap[1].getCurrentValue()*10,uiS2ParameterMap[2].getCurrentValue()*10,uiS2ParameterMap[13].getCurrentValue(),uiS2ParameterMap[14].getCurrentValue());


    //this value for x and y stage is correct (i.e. it moves to the right location in the sample as the microscope galvo or stage changes.
    //however, the x position of the overview tile location is mirrored in x about the stage x = 0 axis.  this error propagates into subsequent locations some of the time!

}

 grabbed a bunch of notes/comments from the s2ui.cpp

AS OF NOW  2016.09.20 17:13
the tile stage data is being collected from the scope when an overview is collected.
the target selection is linked to the stage coordinates of the last overview.
inside s2ui, the galvo location is .x and the stage location is .mcenter.x
when I pass the tile location information to stackAnalyzer, I make .x and .y the global pixel coordinates
                (i.e. account for stage location and account for upper-left origin of the image pixels)
when new locations come back from stackanalyzer, I undo this process, based on the .ev_pc1 and .mcenter.x data from those new locations.


this scheme should work and keeps the stackanalyzer code ignorant of the stage/galvo/whatever and allows it to just spit back image coordinates

remaining work:
0. add stage info to graphicsScene
1. implement stage-only move commands within the s2scan process.  these will be based on the returning .x (after the above corrections)

2. modify the duplicateROI method to first shift to global pixel coordinates before checking.  THIS is really where it's clear that all 3 coordinate
systems should be stored in the struct.  now I'll have to do the subtraction, multiplication, etc for every tile location every time I cycle through them checking for duplicate locations.

3.  test stage-only scans.


4.  how can I work out the case with BOTH modalities?  it really sucks- you have to keep track of edge tiles, bump to the next stage location,
handle all the borderline cases, probably need different logic to prevent retracing.




// for the current scheme, we need to
// log the stage position for each overview.[DONE]
// then assume it's the same for the first tile,  adding the stage position into the location struct for that tile. [DONE]

// basically, at this point,
// the stage info will be incorporated into the .x and .y fields, with the initial stage position set to 0,0  or based on a global coordinate system
// probably centered on the middle of the stage travel.
//


// the problem is just sorting out who pays attention to .x and who pays attention to .mcenter.x and how they're related.
// right now stackAnalyzer only cares about .x and treats all coordinates in relation to the upper left corner of the image data.
// when the coordinates come back, I shift them to the center (handleNewLocations) and when they leave, I shift them to the upper left corner
// (loadlatest)

// I guess I could just add and subtract at those same points...  stackAnalyzer wont know anything about the stage business (good) and I can
// keep track of the stage vs galvo stuff in my move command








// once the tiles come back, how will I be able to check if they've been scanned or not?













// basically, the .x and .y will be the x_stage*pixels/micron  + x_galvo_pixels  and same for y.
//
//  when the locations return, the handler will see .x (pixels, including offset of the source tile) and .xStage from the source tile.
// then, in stage-only mode, the moveLocation command will only adjust the stage, not the galvo. at the same time, the .x and .y values for the location will
// remain the same, but the .xStage will now be updated in the location list, so that info will be passed along to the next location calculation

// possible problem with center vs upper left coordinates here... .x and .y are upper left, but galvo coordinates are centered.  this is handled in the moveTo


//
// modify the stackanalyzer code to keep track of the stage info, basically


//  next phase:  when do you set the stage position?
// the first tile (starting location) can be safely accompanied by a stage location iff the stage location is latched when the image is collected
// the stage information is stored in the .xml file, but that's not currently accessed.
//  for now, this information can be integrated into the 'collectOverview' method.

//  the problem is that this information has to be integrated into the position list
//

/* sketch for integrating stage information:
 option 1:  always include stage information in all tileLocation data
 option 2:  add/account for stage information at the movetoroi time.

o1:   this is conceptually the most straightforward but introduces potential race conditions with stage locations at the exact moment
when the locationSimple.mcenter.x is set.
    basically, now the locationSimple stuff is all just calculated (after the first one which is set by user clicking) and doesn't depend on any
    other events/timing/etc.   the new locations are calculated based on previous ones, regardless of the state of the system

o2:  conceptually more messy and likely to insert itself in many places in the codebase with additional conditional statements...
'switch stageMoveMode  0{asdsdfe}   1{sdfasdf} 2{asdfasdf}
   this would allow you to retain some kind of control over exactly when the stage position is considered, when it's reported, when it's ignored
   etc.
   but it will definitely add another wrinkle into an already messy codebase.

   back to o1:
        you really want 3 things for every tile:
            1. stage Location
            2. galvo location (in pixels is OK)
            3. stage+galvo location in pixels

   for the tile locations in stackAnalyzer,  use (3)
   for the steering of the galvo, use (2)
   for the stage positioning, use (1).

   the problem is:
    when do you convert between them?

1. a new location is determined solely based on (3).  then when the new location comes back, determine if it's outside the current scanUnit
if so, bump it to the next scanUnit, maintaining its (3) but adjusting 1 and 2.

2. this would allow you to maintain both stage info and the correct pixel location.

3. act on the stage location as follows:
   when you're looking through the allLocations for more tiles, you first have to consider the stage position
   basically, i need to make some new methods that act like we're looking for new/any tiles, but are really looking for new/any tiles
   IN THAT STAGE POSITION!
either make some new methods here and use them
or
subclass the list, including methods to return just the list itself

or make a new class that has the list as an attribute...? that's a little dumb.  then this object will end up with multiple copies of the list

I think it's probably simplest to just make the relevant methods here and apply them.















While I'm at it,  is there some of this stuff that could be moved into a separate class?  Like all the locations, lists, etc being
processed by a single object. eventloop problems perhaps? mostly just rewiring to communicate between the s2scan object and this class

it would bascially take:
loadLatest
handleNewLocation
and several other methods

and clean up a bunch of existing methods to turn them from code here into emitting signals from here to the new class.




probably the next best thing would be the ROImonitor.  it has its own graphicsScene, blah blah blah and really not related to running the scope.

Other possibilities:


*/




2016.09.16
yesterday
1.  xy stage info was already being monitored in posMon mode so it's already just as fast as the galvo monitoring.
2. I added xy moves to the various moveToROI methods in s2controller and s2ui signals and hooked it up to a simple testing field/button/whatever

NOW:
1. incorporate stage location into tile location...
locationSimple has .x .y .ev_pc1 .ev_pc2  in use
but there is also
locationSimple.mcenter  which is a 3d coordinate...
locationSimple.mcenter.x .y .z  will represent the current stage motor positions


2016.09.15
uhh  adding stage control to s2...
1. add new s2controller instance to handle the position polling and another to handle the xy position commands

2016.08.30

adding stage control to S2:

1. add relative move commands and stage position updates to s2controller obviously units are important here and have to be tested at the rig with no chance of crashing objective or condenser

2. add hard limits to stage move positions, i.e. a check in s2controller to not allow relative moves or absolute moves beyond certain coordinates.

3. add stage coordinates conversion to pixels and RESET button to 'zero'.  add button to mark stage position by dropping full FOV square on graphicsScene

when you start s2, you should store the current xy position and somehow keep track of difference between planned coordinates (relative movements) and current reported coordinates so you don't end up
with problems if someone zeros the manipulator (!)
>>>> IS THE REPORTED XY STAGE POSITION THE ABSOLUTE VALUE OR THE 'ZERO'd' VALUE?   if it's in relation to a user-set zero, I need to somehow disable that button on the GUI... or constantly poll the above condition
and stop all stage movement if the stage was zeroed.

VERDICT:  zero button on ASI controller = zero on PV GUI, meaning that the zero can be changed at any time by clicking or by zeroing on the ASI box!!

so...
add constant polling to check difference between current location reported by PV and the dead-reckoning location based on s2-initiated movements.  THIS WILL TRIGGER IF SOMEONE EVEN TOUCHES THE JOYSTICK!

wtf. now I have to constantly poll and make sure the current location never gets near zero (?!)  or something to try to ID spurious 'zero' button clicks.

I suppose it's OK-  the idea is that the stage has to be where s2 thinks it is, otherwise it should stop the acquisition.



4. add stage coordinates to s2 sequence... ?
rules:  A. EVERYTHING in each stage location has to be traced before moving stage
        B. stage coordinates will be kept track of during each phase-  you can end up with 4 stage locations from a starting tile...
        C. anything returning back to a previous stage location... ?  check...
        D. add stage coordinates to image tile locations
        E. ALSO keep track of image and stage coordinates separately because you will need both bits of info for debugging.









one way to do this is to essentially add another state to the s2 handler (akin to the automatic BB scan) that only runs after an s2 scan is complete.

basically, the pixel locations we've been using (within one scan unit) and the framework we have currently, the seed locations and tile locations just keep on trucking beyond the limits of the scanunit.
the problem is that once the stage moves, those pixel locations will still be within one scan unit (for the pan galvo commands and tile locations) but the offset will be needed to match them all up.

so the 3 new parameters will be

1.  scanUnitOffset [x,y] set to [0,0] for the first tile
2.  currentStageLocation [x,y] should be constantly polled and kept up-to-date
3.  offsetOffset [x,y] is the 'currentStageLocation' for the first tile... this should be reset at the start of s2scan


the s2scan stuff will only know about the scanUnitOffset
currentStageLocation-offsetOffset will be used to plot scanUnits on the graphicsScene




get this to work, then try to handle multiple starting points...
remember that the xy stage location data is in the .xml file...















>>>>>>>>>>>   add point-and-click for 'new tile'  or 're-image' or whatever.   this could be eventually hooked up to a 're-image' option.





2016.03.25

current problems with adaptive window:
1. tile location (in ROI map and in .tc file) is incorrect relative to the image data.
2. the image data is (probably) what you want (i.e the continuing dendrite in a neighboring area), but the location
is incorrect.

to be clear: the final stitched data does not accurately show continuous structures because the image tiles are placed at the
wrong location. as opposed to placing the tiles at the right location with the wrong image data


so the tile location between the internal stuff (location.x location.y ,etc) and the scan location
needs to be figured out.  maybe shifting the coordinates by half the window is not enough?  also need a global origin shift?

---


ugh.  adaptive window scanning is broken. somehow invalid zooms are being passed to PV.  also PV is not starting the zstack for some reason.




2016.03.02
URGENT:  FIX EVENTLOGGER!   time differences are inconsistent, whole file gets appended multiple times, some negative elapsed times, add summary statistics

 Add tab for configuration info,
add option to run 1 marker or run all markers
Add ROI controls-  with z scan info.
Add total info /progress into dialog at ‘click ok’ and maybe add cancel option.
add mode for resonant control. most code is now robust against active mode, but need a button to set active mode
and ideally a way to assess if it's running properly at the tight zoom


2016.02.26

 Add tab for configuration info,
add option to run 1 marker or run all markers
Add ROI controls-  with z scan info.
Add total info /progress into dialog at ‘click ok’ and maybe add cancel option.
add mode for resonant control. most code is now robust against active mode, but need a button to set active mode
and ideally a way to assess if it's running properly at the tight zoom

2016.02.11  update task list

NEW:
1. add mode for resonant control. most code is now robust against active mode, but need a button to set active mode
and ideally a way to assess if it's running properly at the tight zoom

2. Add tab for configuration info, including button to update save directory. also add code to check for existance of .config save directory

/data/mat/BRL/testData/ZSeries-02112016-1549-1076/ZSeries-02112016-1549-1076_Cycle00001_Ch2_000001.ome.tif

REMAINING FROM PREVIOUS:
add option to run 1 marker or run all markers
Add total info /progress into dialog at ‘click ok’ and maybe add cancel option.
#Try MIP display for each ROI,
Add ROI controls-  with z scan info.
#allow user to generate block grid based on 2 anchor points in preview scan
#...then Automatically scan the whole grid in full resolution.


2015.02.01 meeting generated this chunk of tasks:

# add RESET button to return system (to overview mode?)
#add preview with 3-5 plane MIP
#add cell body markers as starting locations
add option to run 1 marker or run all markers
#add option to pop up window for tracing or not
# add configuration.
REMAINING FROM PREVIOUS:
Add total info /progress into dialog at ‘click ok’ and maybe add cancel option.
Try MIP display for each ROI,
Add ROI controls-  with z scan info.
allow user to generate block grid based on 2 anchor points in preview scan
...then Automatically scan the whole grid in full resolution.



2015.01.27 meeting generated this chunk of tasks.

started 2015.01.28 1545

GUI:

# Move ROI monitor field to another tab on left side. Keep right side devoted to ROI overview graphicsview.



# NoteTaker- make ‘save’ functional,  ALSO ADDED LOCAL SAVE DIRECTORY FOR ALL RELEVANT STACK, SWC, v3draw, etc data

# hook up all qDebug<< and s2LineEdit to status.

# Eliminate display of file reads.

# CLEANED UP stack loading code to eliminate duplicate code. need to test

# add automatic saving of notes file.


# Make “smartScan”  the biggest, first button so the user can see what to do.

# Improve wording on buttons/labels



#Add dialog for ‘entire thing finished’ or similar..






# but it’s more important to display order number on ROI plot.



# Fix ROI xy directions on ROI plot relative to images



# didnt do this- just look for the highest numberDisplay current ROI location in red and/or label ‘current’.



Internal control of the program:


# Add user-adjustable overlap between tiles.





Major Addition:

# testing single plane version>Create method to scan whole area in low-res preview mode with no z (or 3 plane z stack MIP?)  and show the image.



